<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P File Sharing</title>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.3.1/dist/peerjs.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        #fileInput {
            margin-bottom: 10px;
        }
        .progress {
            width: 100%;
            background-color: #f3f3f3;
            margin: 5px 0;
            height: 20px;
            border-radius: 5px;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background-color: #4caf50;
            width: 0;
        }
    </style>
</head>
<body>
    <h1>P2P File Sharing</h1>
    <div>
        <input type="file" id="fileInput" multiple>
        <button id="connect">Connect</button>
        <input type="text" id="peerId" placeholder="Peer ID">
    </div>
    <div id="progressContainer"></div>
    <script>
        const peer = new Peer();
        let conn;
        const chunkSize = 16 * 1024; // 16KB
        const fileQueue = [];
        let isTransferring = false;

        const progressContainer = document.getElementById('progressContainer');
        const fileInput = document.getElementById('fileInput');
        const peerIdInput = document.getElementById('peerId');
        const connectButton = document.getElementById('connect');

        peer.on('open', id => {
            alert(`Your Peer ID: ${id}`);
        });

        connectButton.addEventListener('click', () => {
            const peerId = peerIdInput.value.trim();
            if (peerId) {
                conn = peer.connect(peerId);
                setupConnection();
            } else {
                alert('Please enter a Peer ID to connect.');
            }
        });

        peer.on('connection', connection => {
            conn = connection;
            setupConnection();
        });

        function setupConnection() {
            conn.on('open', () => {
                alert('Connection established.');
            });

            conn.on('data', handleIncomingData);
        }

        fileInput.addEventListener('change', () => {
            const files = fileInput.files;
            for (const file of files) {
                fileQueue.push(file);
            }
            processQueue();
        });

        function handleIncomingData(data) {
            if (data.metadata) {
                receivedChunks[data.metadata.name] = [];
                fileMetadata[data.metadata.name] = data.metadata;
                createProgressBar(data.metadata.name);
            } else if (data.chunk) {
                const { fileName, chunk } = data.chunk;
                receivedChunks[fileName].push(chunk);

                const progress = (receivedChunks[fileName].length / fileMetadata[fileName].totalChunks) * 100;
                updateProgressBar(fileName, progress);

                if (progress === 100) {
                    const fileBlob = new Blob(receivedChunks[fileName], { type: fileMetadata[fileName].type });
                    saveFile(fileBlob, fileName);
                    delete receivedChunks[fileName];
                    delete fileMetadata[fileName];
                }
            }
        }

        const receivedChunks = {};
        const fileMetadata = {};

        function processQueue() {
            if (isTransferring || fileQueue.length === 0) return;

            isTransferring = true;
            const file = fileQueue.shift();
            const reader = new FileReader();

            const totalChunks = Math.ceil(file.size / chunkSize);
            conn.send({ metadata: { name: file.name, type: file.type, totalChunks } });

            reader.onload = () => {
                const fileData = reader.result;
                let offset = 0;

                function sendChunk() {
                    if (offset < fileData.byteLength) {
                        const chunk = fileData.slice(offset, offset + chunkSize);
                        conn.send({ chunk: { fileName: file.name, chunk } });
                        offset += chunkSize;

                        const progress = (offset / fileData.byteLength) * 100;
                        updateProgressBar(file.name, progress);

                        setTimeout(sendChunk, 10);
                    } else {
                        isTransferring = false;
                        processQueue();
                        alert(`File ${file.name} sent successfully.`);
                    }
                }

                sendChunk();
            };

            reader.readAsArrayBuffer(file);
        }

        function createProgressBar(fileName) {
            const progressDiv = document.createElement('div');
            progressDiv.className = 'progress';

            const progressBar = document.createElement('div');
            progressBar.className = 'progress-bar';
            progressBar.id = `progress-${fileName}`;

            progressDiv.appendChild(progressBar);
            progressContainer.appendChild(progressDiv);
        }

        function updateProgressBar(fileName, progress) {
            const progressBar = document.getElementById(`progress-${fileName}`);
            if (progressBar) {
                progressBar.style.width = `${progress}%`;
            }
        }

        function saveFile(blob, fileName) {
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            a.click();
            window.URL.revokeObjectURL(url);
            alert(`File ${fileName} saved.`);
        }
    </script>
</body>
</html>
